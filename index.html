<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Nostril Blaster</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700;800;900&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    background: #000;
    overflow: hidden;
    font-family: 'Vazirmatn', 'Segoe UI', system-ui, -apple-system, sans-serif;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }
  #gameWrapper {
    position: relative;
    width: 100%; height: 100%;
    display: flex; align-items: center; justify-content: center;
  }
  canvas {
    display: block;
    image-rendering: -webkit-optimize-contrast;
  }

  /* --- Overlays --- */
  .overlay {
    position: absolute;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 10;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s ease;
  }
  .overlay.active { opacity: 1; pointer-events: auto; }
  .overlay-card {
    background: rgba(10, 10, 25, 0.92);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 20px;
    padding: 40px 36px;
    text-align: center;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    box-shadow: 0 0 60px rgba(100, 60, 255, 0.25), inset 0 1px 0 rgba(255,255,255,0.08);
    max-width: 360px;
    width: 88%;
  }
  .overlay-card h1 {
    font-family: 'Vazirmatn', sans-serif;
    font-size: 2rem; font-weight: 900;
    background: linear-gradient(135deg, #ff6bcb, #6b8aff, #00e4ff);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
  }
  .overlay-card p {
    font-family: 'Vazirmatn', sans-serif;
    color: rgba(255,255,255,0.6);
    font-size: 0.85rem;
    line-height: 1.8;
    margin-bottom: 24px;
  }
  .overlay-card .score-display {
    font-family: 'Vazirmatn', sans-serif;
    font-size: 3.5rem; font-weight: 900;
    color: #fff;
    margin: 10px 0;
    text-shadow: 0 0 30px rgba(107,138,255,0.5);
  }
  .overlay-card .score-label {
    font-family: 'Vazirmatn', sans-serif;
    color: rgba(255,255,255,0.4);
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 3px;
    margin-bottom: 8px;
  }
  .overlay-card .rank-display {
    font-family: 'Vazirmatn', sans-serif;
    font-size: 1.2rem;
    font-weight: 800;
    direction: rtl;
    margin: 6px 0 20px 0;
    padding: 8px 16px;
    border-radius: 12px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
  }
  .btn {
    font-family: 'Vazirmatn', sans-serif;
    display: inline-block;
    padding: 14px 40px;
    border: none; border-radius: 50px;
    background: linear-gradient(135deg, #6b8aff, #ff6bcb);
    color: #fff;
    font-size: 1rem; font-weight: 700;
    cursor: pointer;
    letter-spacing: 1px;
    text-transform: uppercase;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 25px rgba(107,138,255,0.4);
  }
  .btn:hover { transform: scale(1.05); box-shadow: 0 6px 35px rgba(107,138,255,0.6); }
  .btn:active { transform: scale(0.97); }
  .emoji-big { font-size: 4rem; margin-bottom: 8px; }
  .controls-hint {
    font-family: 'Vazirmatn', sans-serif;
    color: rgba(255,255,255,0.35);
    font-size: 0.7rem;
    margin-top: 16px;
    letter-spacing: 0.5px;
  }
  #gameTitle {
    position: absolute;
    z-index: 5;
    color: #fff;
    font-size: 1.6rem;
    font-weight: 900;
    text-align: center;
    direction: rtl;
    font-family: 'Vazirmatn', 'Segoe UI', Tahoma, 'Arial', sans-serif;
    text-shadow: 0 2px 8px rgba(0,0,0,0.85), 0 0 20px rgba(107,138,255,0.5), 0 0 40px rgba(255,107,203,0.3);
    pointer-events: none;
    letter-spacing: 1px;
    line-height: 1.6;
    padding: 10px 16px;
    background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 100%);
    border-radius: 0 0 12px 12px;
  }
</style>
</head>
<body>

<audio id="bgMusic" loop preload="auto" src="bg-music.mp3"></audio>

<div id="gameWrapper">
  <canvas id="gameCanvas"></canvas>

  <!-- Persian Title -->
  <div id="gameTitle">Ø¨Ù‡ Ø¯Ù…Ø§Øº Ø§ÛŒÙ„ÛŒØ§ Ø´Ù„ÛŒÚ© Ú©Ù†</div>

  <!-- Start Screen -->
  <div id="startScreen" class="overlay active">
    <div class="overlay-card">
      <div class="emoji-big">ğŸ‘ƒğŸš€</div>
      <h1>Nostril Blaster</h1>
      <p>Ø¨Ù‡ Ø¯Ù…Ø§Øº Ø´Ù„ÛŒÚ© Ú©Ù†! Û²Û° Ø«Ø§Ù†ÛŒÙ‡ ÙˆÙ‚Øª Ø¯Ø§Ø±ÛŒ. Ú†Ù†Ø¯ ØªØ§ Ù…ÛŒØªÙˆÙ†ÛŒ Ø¨Ø²Ù†ÛŒØŸ</p>
      <button class="btn" id="startBtn">Ø´Ø±ÙˆØ¹!</button>
      <div class="controls-hint">Space / Click / Tap to shoot</div>
    </div>
  </div>

  <!-- End Screen -->
  <div id="endScreen" class="overlay">
    <div class="overlay-card">
      <div class="emoji-big" id="endEmoji">ğŸ†</div>
      <h1>ØªÙ…ÙˆÙ… Ø´Ø¯!</h1>
      <div class="score-label">Ø§Ù…ØªÛŒØ§Ø² Ù†Ù‡Ø§ÛŒÛŒ</div>
      <div class="score-display" id="finalScore">0</div>
      <div class="rank-display" id="rankDisplay">Ø±ØªØ¨Ù‡: ØªØ§Ø²Ù‡â€ŒÚ©Ø§Ø±</div>
      <p id="endMessage">Ø¢ÙØ±ÛŒÙ†!</p>
      <button class="btn" id="restartBtn">Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¨Ø§Ø²ÛŒ Ú©Ù†</button>
    </div>
  </div>
</div>

<script>
// =============================================
// CONFIGURATION
// =============================================
const DEBUG_MODE = false;
const GAME_DURATION = 35; // seconds

// Configuration for a 1080x1920 Vertical Image
const IMG_CONFIG = {
  width: 1080,
  height: 1920,
  targets: [
    { xMin: 470, xMax: 525, yMin: 910, yMax: 945 }, // Left Nostril
    { xMin: 560, xMax: 625, yMin: 910, yMax: 945 }  // Right Nostril
  ]
};

// =============================================
// GLOBALS
// =============================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const wrapper = document.getElementById('gameWrapper');
const startScreen = document.getElementById('startScreen');
const endScreen = document.getElementById('endScreen');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');
const finalScoreEl = document.getElementById('finalScore');
const endMessageEl = document.getElementById('endMessage');
const rankDisplayEl = document.getElementById('rankDisplay');
const endEmojiEl = document.getElementById('endEmoji');
const bgMusic = document.getElementById('bgMusic');
const gameTitle = document.getElementById('gameTitle');

let gameState = 'idle'; // idle | playing | ended
let score = 0;
let timeLeft = GAME_DURATION;
let gameStartTime = 0;
let lastTime = 0;

// Rendering
let scale = 1;
let offsetX = 0;
let offsetY = 0;
let gameAreaX = 0;
let gameAreaY = 0;
let gameAreaW = 0;
let gameAreaH = 0;

// Player
let player = { x: 0, y: 0, width: 50, height: 40, baseSpeed: 250, dir: 1 };

// Spaceship movement constraints (in image coordinates, 0â€“1080 range)
const SHIP_BOUND_LEFT = 200;
const SHIP_BOUND_RIGHT = 900;

// Bullets
let bullets = [];
const BULLET_SPEED = 800;

// Effects
let screenShake = { intensity: 0, decay: 0.92 };
let redOverlayOpacity = 0;
let starfield = [];
let floatingTexts = [];    // "+1" floating score popups
let muzzleFlash = { active: false, timer: 0, x: 0, y: 0 };

// Face image
let faceImg = null;
let faceImgLoaded = false;

// Scaled target zones (recalculated on resize)
let scaledTargets = [];

// Debug mouse position tracker
let debugMousePos = { x: 0, y: 0, active: false };

// =============================================
// AUDIO CONTEXT â€” Synthesized SFX
// =============================================
let audioCtx = null;

function initAudioContext() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  } catch(e) {
    console.warn('AudioContext not available');
  }
}

function playShootSFX() {
  if (!audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.type = 'square';
    osc.frequency.setValueAtTime(880, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(1760, audioCtx.currentTime + 0.03);
    osc.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.08);

    gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);

    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.1);
  } catch(e) {}
}

function playHitSFX() {
  if (!audioCtx) return;
  try {
    // Satisfying "ding" / thud combo
    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    const gain1 = audioCtx.createGain();
    const gain2 = audioCtx.createGain();

    osc1.connect(gain1);
    gain1.connect(audioCtx.destination);
    osc2.connect(gain2);
    gain2.connect(audioCtx.destination);

    // High ding
    osc1.type = 'sine';
    osc1.frequency.setValueAtTime(1200, audioCtx.currentTime);
    osc1.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.15);
    gain1.gain.setValueAtTime(0.18, audioCtx.currentTime);
    gain1.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);

    // Low thud
    osc2.type = 'triangle';
    osc2.frequency.setValueAtTime(200, audioCtx.currentTime);
    osc2.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.12);
    gain2.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);

    osc1.start(audioCtx.currentTime);
    osc1.stop(audioCtx.currentTime + 0.2);
    osc2.start(audioCtx.currentTime);
    osc2.stop(audioCtx.currentTime + 0.15);
  } catch(e) {}
}

// =============================================
// BACKGROUND IMAGE - Load from file
// =============================================
function loadBackgroundImage() {
  faceImg = new Image();
  faceImg.onload = () => {
    IMG_CONFIG.width = faceImg.naturalWidth;
    IMG_CONFIG.height = faceImg.naturalHeight;
    faceImgLoaded = true;
    console.log(`âœ… background.png loaded: ${IMG_CONFIG.width}x${IMG_CONFIG.height}`);
    if (DEBUG_MODE) {
      console.log('â„¹ï¸  DEBUG_MODE is ON. Green rectangles show target hit zones.');
      console.log('â„¹ï¸  Hover to see image coordinates. Adjust IMG_CONFIG.targets[].');
    }
    resize();
  };
  faceImg.onerror = () => {
    console.error('âŒ Failed to load "background.png". Place it in the same folder as index.html.');
    const offCanvas = document.createElement('canvas');
    offCanvas.width = IMG_CONFIG.width;
    offCanvas.height = IMG_CONFIG.height;
    const c = offCanvas.getContext('2d');
    c.fillStyle = '#1a1a2e';
    c.fillRect(0, 0, IMG_CONFIG.width, IMG_CONFIG.height);
    c.fillStyle = '#ff4444';
    c.font = 'bold 48px sans-serif';
    c.textAlign = 'center';
    c.textBaseline = 'middle';
    c.fillText('âš  background.png not found', IMG_CONFIG.width / 2, IMG_CONFIG.height / 2 - 40);
    c.fillStyle = 'rgba(255,255,255,0.5)';
    c.font = '32px sans-serif';
    c.fillText('Place "background.png" in the same folder', IMG_CONFIG.width / 2, IMG_CONFIG.height / 2 + 30);
    c.fillText('as index.html and refresh.', IMG_CONFIG.width / 2, IMG_CONFIG.height / 2 + 75);
    faceImg = offCanvas;
    faceImgLoaded = true;
  };
  faceImg.src = 'background.png';
}

// =============================================
// STARFIELD
// =============================================
function initStarfield() {
  starfield = [];
  for (let i = 0; i < 80; i++) {
    starfield.push({
      x: Math.random(),
      y: Math.random(),
      size: Math.random() * 2 + 0.5,
      speed: Math.random() * 40 + 10,
      alpha: Math.random() * 0.5 + 0.3
    });
  }
}

function updateStarfield(dt) {
  for (const s of starfield) {
    s.y += s.speed * dt / IMG_CONFIG.height;
    if (s.y > 1) { s.y = 0; s.x = Math.random(); }
  }
}

function drawStarfield() {
  for (const s of starfield) {
    const sx = gameAreaX + s.x * gameAreaW;
    const sy = gameAreaY + s.y * gameAreaH;
    ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
    ctx.beginPath();
    ctx.arc(sx, sy, s.size * scale, 0, Math.PI * 2);
    ctx.fill();
  }
}

// =============================================
// FLOATING SCORE TEXT
// =============================================
function spawnFloatingText(x, y, text) {
  floatingTexts.push({
    x: x,
    y: y,
    text: text || '+1',
    life: 0.6,
    maxLife: 0.6,
    vy: -80 * scale, // float upward speed
    scale: 1.5
  });
}

function updateFloatingTexts(dt) {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    ft.life -= dt;
    ft.y += ft.vy * dt;
    ft.scale *= 0.995; // slightly shrink
    if (ft.life <= 0) {
      floatingTexts.splice(i, 1);
    }
  }
}

function drawFloatingTexts() {
  for (const ft of floatingTexts) {
    const progress = ft.life / ft.maxLife; // 1 â†’ 0
    const alpha = Math.min(1, progress * 2); // fade in last half
    const yOff = (1 - progress) * -10 * scale; // extra drift

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = `bold ${Math.max(18, 28 * scale * ft.scale)}px 'Vazirmatn', sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Shadow / glow
    ctx.shadowColor = 'rgba(255, 200, 50, 0.8)';
    ctx.shadowBlur = 12 * scale;

    // Outline
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 3 * scale;
    ctx.strokeText(ft.text, ft.x, ft.y + yOff);

    // Fill with gradient feel
    ctx.fillStyle = '#ffee44';
    ctx.fillText(ft.text, ft.x, ft.y + yOff);

    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

// =============================================
// MUZZLE FLASH
// =============================================
function triggerMuzzleFlash() {
  muzzleFlash.active = true;
  muzzleFlash.timer = 0.1; // 0.1 seconds
  muzzleFlash.x = player.x;
  muzzleFlash.y = player.y - player.height * 0.6;
}

function updateMuzzleFlash(dt) {
  if (muzzleFlash.active) {
    muzzleFlash.timer -= dt;
    if (muzzleFlash.timer <= 0) {
      muzzleFlash.active = false;
    }
  }
}

function drawMuzzleFlash() {
  if (!muzzleFlash.active) return;

  const progress = muzzleFlash.timer / 0.1; // 1 â†’ 0
  const r = (12 + Math.random() * 6) * scale * progress;
  const x = muzzleFlash.x;
  const y = muzzleFlash.y;

  ctx.save();
  ctx.globalAlpha = progress;

  // Outer glow
  const grad = ctx.createRadialGradient(x, y, 0, x, y, r * 2.5);
  grad.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
  grad.addColorStop(0.3, 'rgba(255, 200, 50, 0.6)');
  grad.addColorStop(0.6, 'rgba(255, 150, 20, 0.2)');
  grad.addColorStop(1, 'rgba(255, 100, 0, 0)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(x, y, r * 2.5, 0, Math.PI * 2);
  ctx.fill();

  // Inner bright core
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(x, y, r * 0.5, 0, Math.PI * 2);
  ctx.fill();

  // Spikes
  ctx.strokeStyle = `rgba(255, 230, 150, ${0.7 * progress})`;
  ctx.lineWidth = 2 * scale * progress;
  for (let a = 0; a < 4; a++) {
    const angle = (a / 4) * Math.PI * 2 + Math.random() * 0.3;
    const len = r * (1.5 + Math.random());
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(angle) * len, y + Math.sin(angle) * len);
    ctx.stroke();
  }

  ctx.restore();
}

// =============================================
// RESIZE & LAYOUT
// =============================================
function resize() {
  canvas.width = wrapper.clientWidth;
  canvas.height = wrapper.clientHeight;

  scale = Math.min(canvas.width / IMG_CONFIG.width, canvas.height / IMG_CONFIG.height);

  gameAreaW = IMG_CONFIG.width * scale;
  gameAreaH = IMG_CONFIG.height * scale;
  gameAreaX = (canvas.width - gameAreaW) / 2;
  gameAreaY = (canvas.height - gameAreaH) / 2;

  offsetX = gameAreaX;
  offsetY = gameAreaY;

  scaledTargets = IMG_CONFIG.targets.map(t => ({
    x: offsetX + t.xMin * scale,
    y: offsetY + t.yMin * scale,
    w: (t.xMax - t.xMin) * scale,
    h: (t.yMax - t.yMin) * scale,
    xCenter: offsetX + ((t.xMin + t.xMax) / 2) * scale,
    yCenter: offsetY + ((t.yMin + t.yMax) / 2) * scale
  }));

  const overlays = document.querySelectorAll('.overlay');
  overlays.forEach(ov => {
    ov.style.left = gameAreaX + 'px';
    ov.style.top = gameAreaY + 'px';
    ov.style.width = gameAreaW + 'px';
    ov.style.height = gameAreaH + 'px';
  });

  if (gameTitle) {
    gameTitle.style.left = gameAreaX + 'px';
    gameTitle.style.top = gameAreaY + 'px';
    gameTitle.style.width = gameAreaW + 'px';
    gameTitle.style.fontSize = Math.max(16, 28 * scale) + 'px';
  }

  player.x = offsetX + gameAreaW / 2;
  player.y = offsetY + gameAreaH - 80 * scale;
  player.width = 50 * scale;
  player.height = 40 * scale;
}

// =============================================
// PLAYER
// =============================================
function updatePlayer(dt, elapsed) {
  const speedMultiplier = 1 + (elapsed / GAME_DURATION) * 3.5;
  const speed = player.baseSpeed * scale * speedMultiplier;

  player.x += player.dir * speed * dt;

  const leftBound = offsetX + SHIP_BOUND_LEFT * scale;
  const rightBound = offsetX + SHIP_BOUND_RIGHT * scale;
  if (player.x <= leftBound) { player.x = leftBound; player.dir = 1; }
  if (player.x >= rightBound) { player.x = rightBound; player.dir = -1; }
}

function drawPlayer() {
  const px = player.x;
  const py = player.y;
  const w = player.width;
  const h = player.height;

  ctx.save();
  ctx.translate(px, py);

  // Engine glow
  const glowGrad = ctx.createRadialGradient(0, h * 0.6, 2, 0, h * 0.6, w * 0.4);
  glowGrad.addColorStop(0, 'rgba(255, 150, 50, 0.8)');
  glowGrad.addColorStop(0.5, 'rgba(255, 80, 20, 0.3)');
  glowGrad.addColorStop(1, 'rgba(255, 50, 10, 0)');
  ctx.fillStyle = glowGrad;
  ctx.beginPath();
  ctx.ellipse(0, h * 0.6, w * 0.35, h * (0.3 + Math.random() * 0.15), 0, 0, Math.PI * 2);
  ctx.fill();

  // Ship body
  ctx.beginPath();
  ctx.moveTo(0, -h * 0.6);
  ctx.lineTo(-w * 0.45, h * 0.4);
  ctx.lineTo(-w * 0.15, h * 0.25);
  ctx.lineTo(0, h * 0.35);
  ctx.lineTo(w * 0.15, h * 0.25);
  ctx.lineTo(w * 0.45, h * 0.4);
  ctx.closePath();
  ctx.fillStyle = '#667ecc';
  ctx.fill();
  ctx.strokeStyle = '#aaccff';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Cockpit
  ctx.fillStyle = '#cef';
  ctx.beginPath();
  ctx.ellipse(0, -h * 0.1, w * 0.1, h * 0.18, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

// =============================================
// BULLETS
// =============================================
function shoot() {
  if (gameState !== 'playing') return;

  initAudioContext();
  playShootSFX();
  triggerMuzzleFlash();

  bullets.push({
    x: player.x,
    y: player.y - player.height * 0.6,
    radius: 4 * scale,
    speed: BULLET_SPEED * scale,
    isHit: false,
    opacity: 1.0,
    trail: []
  });
}

function updateBullets(dt) {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];

    if (b.isHit) {
      b.opacity -= 0.1;
      if (b.opacity <= 0) {
        bullets.splice(i, 1);
        continue;
      }
    } else {
      b.y -= b.speed * dt;

      b.trail.push({ x: b.x, y: b.y, life: 0.15 });
      if (b.trail.length > 10) b.trail.shift();

      for (const t of scaledTargets) {
        if (b.x >= t.x && b.x <= t.x + t.w && b.y >= t.y && b.y <= t.y + t.h) {
          b.isHit = true;
          score++;
          redOverlayOpacity = Math.min(redOverlayOpacity + 0.004, 0.5);
          screenShake.intensity = 8 * scale;

          // Floating "+1" text at hit location
          spawnFloatingText(b.x, b.y, '+1');

          // Hit sound
          playHitSFX();

          break;
        }
      }

      if (!b.isHit && b.y < offsetY - 20) {
        bullets.splice(i, 1);
        continue;
      }
    }

    // Update trail
    for (let j = b.trail.length - 1; j >= 0; j--) {
      b.trail[j].life -= dt;
      if (b.trail[j].life <= 0) b.trail.splice(j, 1);
    }
  }
}

function drawBullets() {
  for (const b of bullets) {
    const alpha = Math.max(0, b.opacity);

    // Trail
    for (const t of b.trail) {
      const ta = (t.life / 0.15) * 0.4 * alpha;
      ctx.fillStyle = `rgba(255, 200, 80, ${ta})`;
      ctx.beginPath();
      ctx.arc(t.x, t.y, b.radius * 0.6, 0, Math.PI * 2);
      ctx.fill();
    }

    // Bullet glow + core
    ctx.save();
    ctx.globalAlpha = alpha;

    const grad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.radius * 2);
    grad.addColorStop(0, '#fff');
    grad.addColorStop(0.3, b.isHit ? '#ff4444' : '#ffcc44');
    grad.addColorStop(1, 'rgba(255,180,50,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius * 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius * 0.6, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

// =============================================
// SCREEN SHAKE
// =============================================
function applyScreenShake() {
  if (screenShake.intensity > 0.5) {
    const dx = (Math.random() - 0.5) * screenShake.intensity * 2;
    const dy = (Math.random() - 0.5) * screenShake.intensity * 2;
    ctx.translate(dx, dy);
    screenShake.intensity *= screenShake.decay;
  } else {
    screenShake.intensity = 0;
  }
}

// =============================================
// DRAWING
// =============================================
function drawBackground() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawFace() {
  if (!faceImgLoaded) return;
  ctx.drawImage(faceImg, offsetX, offsetY, gameAreaW, gameAreaH);
}

function drawRedTint() {
  if (redOverlayOpacity > 0) {
    ctx.fillStyle = "rgba(255, 0, 0, " + redOverlayOpacity + ")";
    ctx.fillRect(offsetX, offsetY, gameAreaW, gameAreaH);
  }
}

function drawDebugTargets() {
  if (!DEBUG_MODE) return;
  ctx.strokeStyle = '#00ff00';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  for (let i = 0; i < scaledTargets.length; i++) {
    const t = scaledTargets[i];
    const orig = IMG_CONFIG.targets[i];
    ctx.strokeRect(t.x, t.y, t.w, t.h);
    ctx.fillStyle = 'rgba(0, 255, 0, 0.12)';
    ctx.fillRect(t.x, t.y, t.w, t.h);
    ctx.fillStyle = '#00ff00';
    ctx.font = `bold ${Math.max(10, 12 * scale)}px monospace`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';
    const label = `Target ${i + 1}: (${orig.xMin},${orig.yMin})â†’(${orig.xMax},${orig.yMax})`;
    ctx.fillText(label, t.x, t.y - 4 * scale);
  }
  ctx.setLineDash([]);

  const shipLeftX = offsetX + SHIP_BOUND_LEFT * scale;
  const shipRightX = offsetX + SHIP_BOUND_RIGHT * scale;
  ctx.strokeStyle = 'rgba(0, 150, 255, 0.5)';
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 6]);
  ctx.beginPath();
  ctx.moveTo(shipLeftX, offsetY + gameAreaH - 120 * scale);
  ctx.lineTo(shipLeftX, offsetY + gameAreaH);
  ctx.moveTo(shipRightX, offsetY + gameAreaH - 120 * scale);
  ctx.lineTo(shipRightX, offsetY + gameAreaH);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(0, 150, 255, 0.7)';
  ctx.font = `bold ${Math.max(9, 10 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillText(`X=${SHIP_BOUND_LEFT}`, shipLeftX, offsetY + gameAreaH - 122 * scale);
  ctx.fillText(`X=${SHIP_BOUND_RIGHT}`, shipRightX, offsetY + gameAreaH - 122 * scale);

  if (debugMousePos.active) {
    const imgX = Math.round((debugMousePos.x - offsetX) / scale);
    const imgY = Math.round((debugMousePos.y - offsetY) / scale);
    const coordText = `Img coords: (${imgX}, ${imgY})`;
    const px = debugMousePos.x;
    const py = debugMousePos.y;

    ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(offsetX, py); ctx.lineTo(offsetX + gameAreaW, py);
    ctx.moveTo(px, offsetY); ctx.lineTo(px, offsetY + gameAreaH);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
    const labelW = 220 * scale;
    const labelH = 24 * scale;
    const labelX = Math.min(px + 12, offsetX + gameAreaW - labelW - 4);
    const labelY = Math.max(py - labelH - 8, offsetY + 4);
    ctx.fillRect(labelX, labelY, labelW, labelH);
    ctx.fillStyle = '#ffff00';
    ctx.font = `bold ${Math.max(11, 13 * scale)}px monospace`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(coordText, labelX + 6, labelY + labelH / 2);
  }

  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawHUD() {
  const hudY = offsetY + 20 * scale;
  const hudPad = 16 * scale;
  const fontSize = Math.max(16, 22 * scale);
  const fontFamily = "'Vazirmatn', 'Segoe UI', sans-serif";

  // Timer
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  roundRect(ctx, offsetX + hudPad, hudY, 120 * scale, 44 * scale, 12 * scale);
  ctx.fill();
  ctx.fillStyle = timeLeft <= 5 ? '#ff5555' : '#fff';
  ctx.font = `bold ${fontSize}px ${fontFamily}`;
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText(`â± ${Math.ceil(timeLeft)}s`, offsetX + hudPad + 12 * scale, hudY + 22 * scale);

  // Score
  const scoreText = `ğŸ¯ ${score}`;
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  roundRect(ctx, offsetX + gameAreaW - hudPad - 120 * scale, hudY, 120 * scale, 44 * scale, 12 * scale);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'right';
  ctx.fillText(scoreText, offsetX + gameAreaW - hudPad - 12 * scale, hudY + 22 * scale);

  // Speed indicator
  if (gameState === 'playing') {
    const elapsed = (Date.now() - gameStartTime) / 1000;
    const speedPct = Math.min(100, Math.round((1 + (elapsed / GAME_DURATION) * 3.5) * 100 / 4.5));
    const barW = 100 * scale;
    const barH = 6 * scale;
    const barX = offsetX + (gameAreaW - barW) / 2;
    const barY = hudY + 36 * scale;

    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(barX, barY, barW, barH);
    const sGrad = ctx.createLinearGradient(barX, 0, barX + barW * speedPct / 100, 0);
    sGrad.addColorStop(0, '#44ff88');
    sGrad.addColorStop(1, '#ff4444');
    ctx.fillStyle = sGrad;
    ctx.fillRect(barX, barY, barW * speedPct / 100, barH);

    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = `${10 * scale}px ${fontFamily}`;
    ctx.textAlign = 'center';
    ctx.fillText('SPEED', offsetX + gameAreaW / 2, hudY + 24 * scale);
  }

  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arcTo(x + w, y, x + w, y + r, r);
  ctx.lineTo(x + w, y + h - r);
  ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
  ctx.lineTo(x + r, y + h);
  ctx.arcTo(x, y + h, x, y + h - r, r);
  ctx.lineTo(x, y + r);
  ctx.arcTo(x, y, x + r, y, r);
  ctx.closePath();
}

function drawVignette() {
  const cx = offsetX + gameAreaW / 2;
  const cy = offsetY + gameAreaH / 2;
  const r = Math.max(gameAreaW, gameAreaH) * 0.7;
  const grad = ctx.createRadialGradient(cx, cy, r * 0.3, cx, cy, r);
  grad.addColorStop(0, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = grad;
  ctx.fillRect(offsetX, offsetY, gameAreaW, gameAreaH);
}

function drawTargetIndicators() {
  if (gameState !== 'playing') return;
  const t = Date.now() / 1000;
  for (const target of scaledTargets) {
    const pulse = Math.sin(t * 4) * 0.3 + 0.7;
    ctx.strokeStyle = `rgba(255, 80, 80, ${0.3 * pulse})`;
    ctx.lineWidth = 1.5;
    const cx = target.xCenter;
    const cy = target.yCenter;
    const sz = Math.max(target.w, target.h) * 1.2;
    ctx.beginPath();
    ctx.arc(cx, cy, sz * 0.6, 0, Math.PI * 2);
    ctx.stroke();
    const len = sz * 0.3;
    ctx.beginPath();
    ctx.moveTo(cx - sz * 0.6 - len, cy); ctx.lineTo(cx - sz * 0.6 + 4, cy);
    ctx.moveTo(cx + sz * 0.6 + len, cy); ctx.lineTo(cx + sz * 0.6 - 4, cy);
    ctx.moveTo(cx, cy - sz * 0.6 - len); ctx.lineTo(cx, cy - sz * 0.6 + 4);
    ctx.moveTo(cx, cy + sz * 0.6 + len); ctx.lineTo(cx, cy + sz * 0.6 - 4);
    ctx.stroke();
  }
}

// =============================================
// GAME LOOP
// =============================================
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  if (gameState === 'playing') {
    const elapsed = (Date.now() - gameStartTime) / 1000;
    timeLeft = Math.max(0, GAME_DURATION - elapsed);

    updatePlayer(dt, elapsed);
    updateBullets(dt);
    updateStarfield(dt);
    updateFloatingTexts(dt);
    updateMuzzleFlash(dt);

    if (timeLeft <= 0) {
      endGame();
    }
  }

  // --- DRAW ---
  ctx.save();
  drawBackground();
  applyScreenShake();

  // Clip to game area
  ctx.save();
  ctx.beginPath();
  ctx.rect(offsetX, offsetY, gameAreaW, gameAreaH);
  ctx.clip();

  drawFace();
  drawStarfield();
  drawRedTint();
  drawVignette();
  drawTargetIndicators();
  drawDebugTargets();

  if (gameState === 'playing') {
    drawBullets();
    drawMuzzleFlash();
    drawPlayer();
    drawFloatingTexts();
    drawHUD();
  }

  ctx.restore();
  ctx.restore();

  // Game area border
  ctx.strokeStyle = 'rgba(100, 130, 255, 0.15)';
  ctx.lineWidth = 1;
  ctx.strokeRect(offsetX, offsetY, gameAreaW, gameAreaH);

  requestAnimationFrame(gameLoop);
}

// =============================================
// GAME STATE
// =============================================
function startGame() {
  initAudioContext();

  score = 0;
  timeLeft = GAME_DURATION;
  gameStartTime = Date.now();
  bullets = [];
  floatingTexts = [];
  redOverlayOpacity = 0;
  screenShake.intensity = 0;
  muzzleFlash.active = false;
  player.dir = 1;
  player.x = offsetX + gameAreaW / 2;

  gameState = 'playing';
  startScreen.classList.remove('active');
  endScreen.classList.remove('active');

  try { bgMusic.currentTime = 0; bgMusic.play().catch(() => {}); } catch(e) {}
}

function endGame() {
  gameState = 'ended';
  finalScoreEl.textContent = score;

  // Dynamic Persian rank system
  let rank, emoji, color;
  if (score < 20) {
    rank = 'Ø±ØªØ¨Ù‡ 1: Ú©ØµÙ„ÛŒØ³ Ù†Ú¯ÛŒÙ† ğŸ‘µ';
    emoji = 'ğŸ˜…';
    color = '#aaa';
  } else if (score < 40) {
    rank = 'Ø±ØªØ¨Ù‡ 2: Ø®Ø§ÛŒÙ…Ø§Ù„ Ù¾Ø±ÛŒØ³Ø§ ğŸ¯';
    emoji = 'ğŸ‘';
    color = '#6b8aff';
  } else if (score < 60) {
    rank = 'Ø±ØªØ¨Ù‡ 3: Ù¾Ø§Ù„ÛŒØ³ Ø§ÛŒÙ„Ø¯Ø§ ğŸ”¥';
    emoji = 'ğŸ†';
    color = '#ffaa00';
  } else if (score < 90) {
    rank = 'Ø±ØªØ¨Ù‡ 4: Ø¨Ø§Ø¨Ø§ÛŒÛŒ Ú©ÛŒÙ…ÛŒØ§ ğŸ”¥';
    emoji = 'ğŸ†';
    color = '#ffaa00';
    } else if (score < 110) {
    rank = 'Ø±ØªØ¨Ù‡ 5: Ø¨Ú©Ù† Ù¾Ø±ÛŒØ§ Ù¾Ø§Ù¾ÛŒÙ„ÙˆÙ†ÛŒ ğŸ”¥';
    emoji = 'ğŸ†';
    color = '#ffaa00';
    } else if (score < 130) {
    rank = 'Ø±ØªØ¨Ù‡ 6: Ú©ÛŒØ±Ø®ÙˆØ± Ø±ÛŒØ­Ø§Ù†Ù‡ ğŸ”¥';
    emoji = 'ğŸ†';
    color = '#ffaa00';
    } else if (score < 150) {
    rank = 'Ø±ØªØ¨Ù‡ 7: Ø¨Ú©Ù† Ø­Ø±ÙÙ‡ Ø§ÛŒ Ú©ÛŒÙ…ÛŒØ§ ğŸ”¥';
    emoji = 'ğŸ†';
    color = '#ffaa00';
    } else if (score < 180) {
    rank = 'Ø±ØªØ¨Ù‡ 8: ÙˆÛŒØ¨Ø±Ø§ØªÙˆØ± Ø²Ù† Ø§ÛŒÙ„ÛŒØ§ ğŸ”¥';
    emoji = 'ğŸ†';
    color = '#ffaa00';
    } else if (score < 220) {
    rank = 'Ø±ØªØ¨Ù‡ 9: Ø®Ø§ÛŒÙ…Ø§Ù„ Ù¾Ù‡Ù„ÙˆÛŒ ğŸ”¥';
    emoji = 'ğŸ†';
    color = '#ffaa00';
  } else {
    rank = 'Ø±ØªØ¨Ù‡ 10: Ø¨Ú©Ù† Ù…Ø³Ø¹ÙˆØ¯ ğŸ‘ƒğŸ’€';
    emoji = 'ğŸ’€';
    color = '#ff4444';
  }

  rankDisplayEl.textContent = rank;
  rankDisplayEl.style.color = color;
  rankDisplayEl.style.borderColor = color + '44';
  rankDisplayEl.style.background = color + '12';
  endEmojiEl.textContent = emoji;

  // Persian messages
  if (score <50) endMessageEl.textContent = "Ø´Ø§ÛŒØ¯ Ø¯ÙØ¹Ù‡ Ø¨Ø¹Ø¯ Ø¯Ù…Ø§ØºÙˆ Ø¨Ø¨ÛŒÙ†ÛŒ! ğŸ˜‚";
  else if (score < 100) endMessageEl.textContent = "Ø¨Ø¯ Ù†Ø¨ÙˆØ¯! ØªÙ…Ø±ÛŒÙ† Ú©Ù†! ğŸ’ª";
  else if (score < 150) endMessageEl.textContent = "Ù†Ø´ÙˆÙ†Ù‡â€ŒÚ¯ÛŒØ±ÛŒØª Ø®ÙˆØ¨Ù‡! ğŸ¯";
  else if (score < 200) endMessageEl.textContent = "ÙˆØ§ÛŒ! ØªÚ©â€ŒØªÛŒØ±Ø§Ù†Ø¯Ø§Ø² ÙˆØ§Ù‚Ø¹ÛŒ! ğŸ”¥";
  else endMessageEl.textContent = "Ø§ÙØ³Ø§Ù†Ù‡â€ŒØ§ÛŒ! Ù†Ø§Ø¨ÙˆØ¯Ú¯Ø± Ù…Ø·Ù„Ù‚ Ø¯Ù…Ø§Øº! ğŸ’€ğŸš€";

  setTimeout(() => { endScreen.classList.add('active'); }, 300);
  try { bgMusic.pause(); } catch(e) {}
}

// =============================================
// INPUT
// =============================================
function handleShoot(e) {
  if (e) e.preventDefault();
  if (gameState === 'playing') shoot();
}

window.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    e.preventDefault();
    handleShoot();
  }
});

canvas.addEventListener('mousedown', (e) => {
  handleShoot(e);
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('touchstart', (e) => {
  handleShoot(e);
}, { passive: false });

startBtn.addEventListener('click', startGame);
startBtn.addEventListener('touchend', (e) => { e.preventDefault(); startGame(); });
restartBtn.addEventListener('click', startGame);
restartBtn.addEventListener('touchend', (e) => { e.preventDefault(); startGame(); });

// Debug mouse tracking
if (DEBUG_MODE) {
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    debugMousePos.x = e.clientX - rect.left;
    debugMousePos.y = e.clientY - rect.top;
    debugMousePos.active = true;
  });
  canvas.addEventListener('mouseleave', () => {
    debugMousePos.active = false;
  });
}

window.addEventListener('resize', resize);
window.addEventListener('orientationchange', () => setTimeout(resize, 100));

// =============================================
// INIT
// =============================================
loadBackgroundImage();
initStarfield();
resize();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
